// intellij + gradle + groovy = pain

//file:noinspection GroovyUnusedAssignment
//file:noinspection GrUnresolvedAccess
plugins {
    id "java"
    id "application"
}

repositories {
    maven {
        url "https://m2.dv8tion.net/releases"
        name "m2-dv8tion"
        content {
            includeGroup "net.dv8tion"
            includeGroup "com.sedmelluq"
        }
    }

    maven {
        url "https://m2.chew.pro/releases"
        name "m2-chew"
        content {
            includeGroup "pw.chew"
        }
    }
    
    maven {
        url "https://jitpack.io"
        name "jitpack"
    }
    mavenCentral()
}

compileJava.options.encoding = "UTF-8"

sourceCompatibility = 17
targetCompatibility = 17

dependencies {
    implementation "com.google.guava:guava:31.1-jre"

    implementation "com.google.code.gson:gson:2.9.0"
    implementation "com.github.Marcono1234:gson-record-type-adapter-factory:v0.2.0"

    implementation "net.dv8tion:JDA:5.0.0-alpha.12"
    implementation "com.github.BlitzOffline:Pagination-Utils:master-SNAPSHOT"
    implementation "pw.chew:jda-chewtils:1.24.1"

    implementation "com.github.Mokulu:discord-oauth2-api:1.0.2"

    implementation "com.github.walkyst:lavaplayer-fork:1.3.98.1"

    implementation "io.javalin:javalin:4.6.4"

    implementation "org.json:json:20220320"

    implementation "org.mongodb:mongo-java-driver:3.12.11"

    implementation "club.minnced:discord-webhooks:0.8.0"

    implementation 'se.michaelthelin.spotify:spotify-web-api-java:7.1.0'

    implementation "com.vdurmont:emoji-java:5.1.1"

    implementation "org.reflections:reflections:0.10.2"

    implementation "commons-validator:commons-validator:1.7"

    implementation "com.google.zxing:core:3.5.0"
    implementation "com.google.zxing:javase:3.5.0"

    implementation "ch.qos.logback:logback-classic:1.2.11"
    implementation "uk.org.lidalia:sysout-over-slf4j:1.0.2"

    implementation "io.github.classgraph:classgraph:4.8.147"

    implementation "io.prometheus:simpleclient:0.15.0"
    implementation "io.prometheus:simpleclient_hotspot:0.15.0"
    implementation "io.prometheus:simpleclient_httpserver:0.15.0"

    testImplementation "org.junit.jupiter:junit-jupiter:5.8.2"
    testImplementation "com.github.erosb:everit-json-schema:1.14.1"
}

test {
    useJUnitPlatform()
}

configurations.all {
    //noinspection GrUnresolvedAccess
    // ez vulnerability fix
    exclude group: "org.slf4j", module: "slf4j-log4j12"
}

mainClassName = "com.github.black0nion.blackonionbot.Main"

version = System.getenv("VERSION") ?: "dev"
processResources {
    def locAndFiles = getLoc()

    filesMatching("bot.metadata.json") {
        expand(
                version: version,
                lines_of_code: locAndFiles.get(0),
                files: locAndFiles.get(1)
        )
    }
}

jar {
    archiveVersion.set("")
}

/**
 * This task downloads all dependencies (with transitive dependencies) and puts them into the libraries folder.
 * Used instead of shadowJar to hopefully optimize build times.
 * Run the application jar with the downloaded library files in the classpath.
 */
task downloadDependencies {
    doLast {
        logger.info("Cleaning up...")
        // delete superseded library jars
        List<String> newFiles = sourceSets.main.runtimeClasspath.getFiles().stream().map(File::getName).toList()
        for (File file : new File("libraries").listFiles()) {
            if (!file.getName().endsWith(".jar") || !newFiles.contains(file.getName())) {
                // why do i have to cast this to string? hello intellij? or gradle? or idk
                System.out.println((String) ("Deleting unnecessary file " + file.getName()))
                file.delete()
            }
        }
        logger.info("Copying dependencies...")
        copy {
            from(sourceSets.main.runtimeClasspath) {
                include "*.jar"
            }
            into 'libraries/'
        }
        logger.info("Successfully copied dependencies into libraries folder!")
    }
}

def getLoc() {
    int linesOfCode = 0
    int filesCount = 0
    project.sourceSets.main.allSource.srcDirs.each { File dir ->
        if (dir.isDirectory()) {
            dir.eachFileRecurse { File file ->
                if (file.isFile()) {
                    file.eachLine(e -> linesOfCode++)
                    filesCount++
                }
            }
        }
    }
    return [linesOfCode, filesCount]
}
